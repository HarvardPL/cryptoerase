// Assumes polyglot.jar is in classpath
include "polyglot/parse/java12.cup"

package cryptoerase.parse;

import cryptoerase.ast.*;
import cryptoerase.types.*;
import polyglot.parse.*;

parser Grm extends polyglot.parse.Grm {:
    public final CryptoEraseTypeSystem ts;
    public final CryptoEraseNodeFactory nf;

    public Grm(Lexer l, CryptoEraseTypeSystem t, CryptoEraseNodeFactory n, ErrorQueue q) {
        super(l, t, n, q);
        ts = t;
        nf = n;
    }
:};

terminal Token CONDITION; // primitive_type
terminal Token TRIGGER; // trigger expression.


non terminal Expr condition;
non terminal Expr accesspath;
non terminal Receiver accesspath_receiver;
non terminal PolicyNode label, label_opt;
non terminal PolicyNode erasure_policy, erasure_policy_b;
non terminal TypeNode labeled_primitive_type;

start with goal;

condition ::=
        accesspath:a {:  RESULT = a;  :}
     |  NOT:x accesspath:a {:  RESULT = parser.nf.Unary(parser.pos(x, a), a, Unary.NOT);  :}
     ;



extend primitive_type ::=
                    // TypeNode
        CONDITION:a
            {: RESULT = parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Condition()); :}
    ;


accesspath ::=
        IDENTIFIER:a
            {: RESULT = parser.nf.Local(parser.pos(a), parser.nf.Id(parser.pos(a), a.getIdentifier())); :}
    |   accesspath_receiver:a DOT IDENTIFIER:b
            {: RESULT = parser.nf.Field(parser.pos(a, b),
                                        a,
                                        b.getIdentifier());
            :}
    ;

accesspath_receiver ::=
        THIS:a {:  RESULT = parser.nf.This(parser.pos(a));  :}
    |   IDENTIFIER:a {: RESULT = parser.nf.Local(parser.pos(a), parser.nf.Id(parser.pos(a), a.getIdentifier())); :}
    |   accesspath_receiver:a DOT IDENTIFIER:b
            {: RESULT = parser.nf.Field(parser.pos(a, b),
                                        a,
                                        b.getIdentifier());
            :}
    ;



label ::=
       // PolicyNode
       LBRACE:x erasure_policy:a RBRACE:y
            {: 
               RESULT = a;
              :}
     ;
     
label_opt ::=
                    // PolicyNode
            {: RESULT = null; :}
    |   label:a
            {: RESULT = a; :}
    ;
     

erasure_policy ::=
       // PolicyNode
    | erasure_policy_b:p  {: RESULT = p;                                          
                    :}
    | erasure_policy:p DIV condition:c erasure_policy_b:q {: RESULT = parser.nf.PolicyErasure(parser.pos(p,q),
                                        p, c, q); :}
    ;

erasure_policy_b ::=
       // PolicyNode
      IDENTIFIER:a {: RESULT = parser.nf.PolicyLevel(parser.pos(a),
                                        a.getIdentifier()); 
                                        
                    :}
    | LPAREN:a erasure_policy:p RPAREN:b {: RESULT = p;                                          
                    :}

    ;
    
    
override 
type ::=
                    // TypeNode
        primitive_type:a label_opt:b
            {: RESULT = a; :}
    |   reference_type:a label_opt:b
            {: RESULT = a; :}
    ;

    